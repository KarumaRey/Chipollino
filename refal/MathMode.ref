/* Crazy Refal-style. Bracket balance is completely ignored, since it does not affect anything. We assume no epsilons in indices! */
$ENTRY TrueMathMode {
 'eps'e.Input = '\\empt'<TrueMathMode e.Input>;
  e.Input'eps' = <TrueMathMode e.Input>'\\empt';
   = ;
 e.Input = '\\regexpstr{'<MathMode e.Input>'}';
}

AdjustSpaceBeforeStar {
 e.x, <LastSym (<Numbers>) e.x> :
 { True = '\\hspace*{-0.5ex}';
   False = '\\hspace*{-0.09ex}';
 };
}

MathMode {
 e.x'|'e.y = <MathMode e.x>'\\alter '<MathMode e.y>;
 e.x'*'e.y = <MathMode e.x>'{}'<AdjustSpaceBeforeStar e.x>'\\star '<MathMode e.y>;
 e.x = <IndexModes Outer ()() e.x>;
}

AnnoteLinearizeIfNeeded {
 e.Ind e.y
 , <InSet (<AnnoteSym><LinearizeSym>)(e.Ind)> : True = <AnnoteLinearize e.Ind e.y>;
 e.Z = <HorizHack e.Z>;
}

IndexModes {
 s.AnyMode (e.Before)(e.Index) e.Ind e.y
 , <InSet (<AnnoteSym><LinearizeSym>)(e.Ind)> : True
 , <IndexCont e.y> : 
  {True
   = <IndexModes Index (e.Before)(e.Index e.Ind) e.y>;
   False
  ,  s.AnyMode :
  {Index
    = <Epsilon e.Before>'_{'<AnnoteLinearizeIfNeeded e.Index>'}'<IndexModes Outer (e.Ind)() e.y>;
   Outer
    = <IndexModes Outer (e.Before e.Ind)() e.y>;
  }; };
 s.AnyMode (e.Before)(e.Index) s.Sym e.y
 , <InSet (<Numbers>) s.Sym > : 
 { True
  , s.AnyMode :
 {Index = <IndexModes Index (e.Before)(e.Index s.Sym) e.y>;
  Outer,
   <LastSym (<Letters>)e.Before> :
  {True = <IndexModes Index (e.Before)(e.Index s.Sym) e.y>;
   False = <IndexModes Outer (e.Before s.Sym)() e.y>
 };};
   False
  , s.AnyMode :
  {Index = <Epsilon e.Before>'_{'<AnnoteLinearizeIfNeeded e.Index>'}'<IndexModes Outer (s.Sym)() e.y>;
   Outer = <IndexModes Outer (e.Before s.Sym)() e.y>;};
 };
 Outer (e.Before)() s.Any e.y
   = <IndexModes Outer (e.Before s.Any)() e.y>;
 Outer (e.Before)() = <Epsilon e.Before>;
 Index (e.Before)(e.Index) = <Epsilon e.Before>'_{'<AnnoteLinearizeIfNeeded e.Index>'}';
}

IndexCont {
 e.Ind e.y
 , <InSet (<AnnoteSym><LinearizeSym>) (e.Ind)> : True
  = <FirstSym (<Numbers>) e.y>;
 s.Sym e.y = <InSet (<Numbers>) s.Sym>;
 e.Z = False;
}

Epsilon {
 e.Eps e.Z, <InSet (<EpsilonSym>) (e.Eps)> : True = '}\\empt\\regexpstr{'<Epsilon e.Z>;
 s.x e.Z = s.x <Epsilon e.Z>;
  = ;
}

/* We assume that every numeric index is preceded with an annotation showing the annotation source
   Namely, every index coming from Linearize is preceded with a dot, and every index coming from Annote is preceded with a comma
   Rendered linearize indices are faint, and annote indices are full-colored. They are separated by 0.5ex intervals
*/
AnnoteLinearize {
 e.Linear e.x e.y
 , <InSet (<LinearizeSym>) (e.Linear)><InSet (<Numbers>) e.x><FirstSym (<Numbers>) e.y> : True True False
   = '\\pgfsetfillopacity{0.6}{'<HorizHack e.x>'}\\pgfsetfillopacity{1}'<SeparateAnnote e.y><AnnoteLinearize e.y>;
 e.Annote e.x e.y
 , <InSet (<AnnoteSym>)(e.Annote)><InSet (<Numbers>) e.x><FirstSym (<Numbers>) e.y> : True True False
   = '{'<HorizHack e.x>'}'<SeparateAnnote e.y><AnnoteLinearize e.y>;
  e.y = <HorizHack e.y>; /* This must be a plain number without any annotation, so do nothing - merely HorizHack */
}

SeparateAnnote {
 e.y, <FirstSym (<IndicesAlphabet>) e.y> :
 { True = '\\hspace{-0.07ex},\\hspace{-0.05ex}';
   False = ;
 };
}

$ENTRY Separator {
 (e.Before)',' e.After
 , <FirstSym (<Numbers>) e.After> : 
 { True = False;
   False = True;
 };
 (e.Before) t.Any e.After = False;
}


HorizHack {
  = ;
 s.x e.y = '\\hspace*{-0.09ex}'s.x<HorizHack e.y>;
}

$ENTRY IndicesAlphabet {
 = '0123456789.,';
}

LinearizeSym {
 = ('.');
}

AnnoteSym {
 = (',');
}

EpsilonSym {
 = 'eps';
}

$ENTRY Numbers {
 = '0123456789';
}

$ENTRY Letters {
 = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM';
}

InSet {
 (e.x) t.Next e.data
 , e.x :
 { e.x1 t.Next e.x2 = <InSet (e.x) e.data>;
   e.xx = False;
 };
 (e.x) = True;
}

$ENTRY FirstSym {
 (e.x) t.Next e.data
 , e.x :
 { e.x1 t.Next e.x2 = True;
   e.xx = False;
 };
 (e.x) = False;
}

$ENTRY LastSym {
 (e.x) e.data t.Next 
 , e.x :
 { e.x1 t.Next e.x2 = True;
   e.xx = False;
 };
 (e.x) = False;
}